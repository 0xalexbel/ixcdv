import * as types from '../common/common-types.js';
import * as pkgTypes from '../pkgmgr/pkgmgr-types.js';
import * as path from 'path';
import assert from 'assert';
import * as git from '../git/git.js';
import { fileExists, readFile, saveToFileSync } from '../common/fs.js';
import { ensureSuffix, removeSuffix } from '../common/string.js';
import { addFile } from '../git/git-api.js';
import { getRepoServiceType } from '../common/utils.js';
import { PROD_VAR_PREFIX } from '../common/consts.js';

const FIX_BUILD_PROPERTIES_BASENAME = `Fix_${PROD_VAR_PREFIX}_AutoGeneratedClass_BuildProperties`;

/**
 * @param {!pkgTypes.Setup} setup
 */
export function getDepRootProjectNameSuffix(setup) {
    const mainPkgArg = setup.directories[setup.mainDir].pkgArg;
    const mainGitHubRepoName = mainPkgArg.gitHubRepoName;
    assert(mainGitHubRepoName);
    return getRepoServiceType(mainGitHubRepoName);
}

/**
 * @param {!string} buildDotGradleRelPath
 * @param {!string} dir 
 * @param {!pkgTypes.Setup} setup
 */
export async function patchBuildDotGradle(buildDotGradleRelPath, dir, setup) {
    const depProjectNameSuffix = getDepRootProjectNameSuffix(setup);

    //gradleDependencies
    const pkgDir = setup.directories[dir];
    assert(pkgDir);

    if (!pkgDir.gradleDependencies) {
        return true;
    }

    const deps = Object.keys(pkgDir.gradleDependencies);
    if (deps.length === 0) {
        return true;
    }

    assert(pkgDir.pkgArgCommitInfo);

    /* --------------------------------------------------------------------- */
    // Retrieve the right version of the 'build.gradle' file
    // using the provided git hash value.
    /* --------------------------------------------------------------------- */

    const out_show = await git.show(
        dir,
        [pkgDir.pkgArgCommitInfo.hash + ":" + buildDotGradleRelPath],
        { strict: false });

    // No 'build.gradle' file ?
    if (!out_show.ok || !out_show.result) {
        return true;
    }

    let str = out_show.result;
    for (let i = 0; i < deps.length; ++i) {
        // Ex: depPkgName === 'iexec-common' 
        const depPkgName = deps[i];
        const depPkgDirName = pkgDir.gradleDependencies[depPkgName];
        const depPkgDir = setup.directories[depPkgDirName];
        assert(depPkgDir);
        assert(depPkgName === depPkgDir.pkgArgGradleVersions?.name);
        if (depPkgName === 'iexec-common') {
            // Ex: depProjectNameSuffix === 'sms'
            // replace :
            // - 'implementation "com.iexec.common:iexec-common:$'
            // by
            // - 'implementation "com.iexec.common:iexec-common-sms:$'
            str = str.replace(
                `implementation "com.iexec.common:iexec-common:$`,
                `implementation "com.iexec.common:iexec-common-${depProjectNameSuffix}:$`);
        } else {
            //assert(false);
        }
    }

    // str = str.replace(
    //     `implementation project(':iexec-sms-library')`,
    //     `implementation project(':iexec-sms-library-${depProjectNameSuffix}')`);
    // console.log(str);

    console.log(str);
    const p = path.join(dir, buildDotGradleRelPath);
    return saveToFileSync(str, path.dirname(p), path.basename(p));
}

/**
 * @param {!string} dir 
 * @param {!pkgTypes.Setup} setup
 */
export async function patchSettingsDotGradle(dir, setup) {

    const isMain = true; //(dir === setup.mainDir);

    //gradleDependencies
    const pkgDir = setup.directories[dir];
    assert(pkgDir);

    if (!pkgDir.gradleDependencies && isMain) {
        return true;
    }

    const deps = (pkgDir.gradleDependencies) ? Object.keys(pkgDir.gradleDependencies) : [];
    assert(pkgDir.pkgArgCommitInfo);

    /* --------------------------------------------------------------------- */
    // Retrieve the right version of the 'settings.gradle' file
    // using the provided git hash value.
    /* --------------------------------------------------------------------- */

    const out_show = await git.show(
        dir,
        [pkgDir.pkgArgCommitInfo.hash + ":" + 'settings.gradle'],
        { strict: false });

    // No 'settings.gradle' file ?
    if (!out_show.ok || !out_show.result) {
        return true;
    }

    // For each dependency, append something like: 
    // includeBuild '../iexec-common'
    let str = out_show.result;
    const endsWithNewLine = str.endsWith('\n');
    let prefix = (endsWithNewLine) ? '' : '\n';

    // if (!isMain) {
    //     // Replace project root name if not main project
    //     // rootProject.name = <dep-name> by rootProject.name = <dep-name>-<main-name>
    //     // Ex: rootProject.name = 'iexec-sms' by rootProject.name = 'iexec-sms-core'
    //     // Ex: rootProject.name = 'iexec-common' by rootProject.name = 'iexec-common-sms'
    //     const depRootProjectNameSuffix = getDepRootProjectNameSuffix(setup);
    //     assert(depRootProjectNameSuffix);
    //     const search = "rootProject.name = '";
    //     const pos = str.indexOf(search);
    //     assert(pos === 0);
    //     let posNewLine = str.indexOf('\n');
    //     if (posNewLine < 0) {
    //         posNewLine = str.length;
    //     }
    //     assert(str.charAt(posNewLine-1) === "'");
    //     const projName = str.substring(pos + search.length, posNewLine-1);
    //     str = str.replace(search + projName + "'",  search + projName + "-" + depRootProjectNameSuffix + "'");
    // }

    for (let i = 0; i < deps.length; ++i) {
        assert(pkgDir.gradleDependencies);
        const depPkgName = deps[i];
        const depPkgDirName = pkgDir.gradleDependencies[depPkgName];
        const depPkgDir = setup.directories[depPkgDirName];
        assert(depPkgDir);

        str += `${prefix}includeBuild '${path.relative(dir, depPkgDirName)}'`;
        prefix = '\n';
    }

    if (endsWithNewLine) {
        str = ensureSuffix('\n', str);
    }

    console.log(str);
    return saveToFileSync(str, dir, 'settings.gradle');
}

/**
 * Returns `true` if fix is needed
 * @param {!string} dir 
 * @param {!pkgTypes.Setup} setup
 * @param {!string} versionServiceJavaRelPath 
 */
export async function patchBuildInfoIfNeeded(
    dir,
    setup,
    versionServiceJavaRelPath) {

    const pkgDir = setup.directories[dir];
    assert(pkgDir);
    assert(pkgDir.pkgArgGradleVersions);
    assert(pkgDir.pkgArgGradleVersions.version);
    assert(pkgDir.pkgArgCommitInfo);
    assert(pkgDir.pkgArg);
    assert(pkgDir.pkgArg.gitHubRepoName);

    let suffix = '';
    if (!pkgDir.pkgArgCommitInfo?.semver) {
        suffix = '-NEXT-SNAPSHOT';
    }

    const versionServiceJavaFile = path.join(dir, versionServiceJavaRelPath);

    const version = (pkgDir.pkgArgCommitInfo.semver)
        ? pkgDir.pkgArgCommitInfo.semver.version
        : pkgDir.pkgArgGradleVersions.version + '-NEXT-SNAPSHOT';

    const versionPackage = await isBuildPropertiesFixNeeded(versionServiceJavaFile);
    if (versionPackage) {
        console.debug(`Patch '${pkgDir.pkgArg.gitHubRepoName}' : version package = ${versionPackage}`);
        console.debug(`Patch '${pkgDir.pkgArg.gitHubRepoName}' : version = ${version}`);
        const fixFile = generateBuildPropertiesFixClassFile(
            path.dirname(versionServiceJavaFile),
            versionPackage,
            version, { strict: false });
        if (!fixFile) {
            console.error(`Patch '${pkgDir.pkgArg.gitHubRepoName}' : Fix '${versionServiceJavaRelPath}' failed.`);
            return false;
        }

        const relFixFile = path.relative(dir, fixFile);
        assert(fileExists(path.join(dir, relFixFile)));

        // git add
        const out = await addFile(dir, relFixFile, { strict: false });
        if (!out.ok) {
            console.error(out.error.message);
            return false;
        }
    }

    return true;
}

/**
 * Returns `true` if fix is needed
 * @param {!string} versionServiceJavaFile 
 */
async function isBuildPropertiesFixNeeded(versionServiceJavaFile) {
    let str = await readFile(versionServiceJavaFile, { strict: false });
    if (!str) {
        return null;
    }
    if (str.indexOf('import org.springframework.boot.info.BuildProperties;') < 0) {
        return null;
    }

    // Extract package name
    const package_str = 'package '
    const i = str.indexOf(package_str);
    if (i >= 0) {
        const j = str.indexOf('\n', i);
        if (j >= 0) {
            str = str.substring(i + package_str.length, j).trim();
            return removeSuffix(';', str);
        }
    }
    return null;
}

/**
 * Generates a file named 'Fix_xxxx_AutoGeneratedClass_BuildProperties.java' 
 * next to 'Version.java' to fix the 'BuildProperties' bean resolution issue in vscode.
 * @param {!string} dir directory where the .java file should be saved
 * @param {!string} packageName full name of the java class package
 * @param {!string} versionName version string the 'getVersion' method should return
 * @param {types.Strict=} options
 */
function generateBuildPropertiesFixClassFile(dir, packageName, versionName, options = { strict: false }) {
    const className = FIX_BUILD_PROPERTIES_BASENAME;

    const javaCode = `// This is an auto-generated file to fix a 'gradle' + 'vscode' startup issue
// This file is NOT part of the original git repository
//
// HERE IS THE SITUATION : it is not possible (to my knowledge) to launch the vscode debugger using 
// a standard launch.json configuration 
// An exception is raised at init-time. Spring is not able to retrieve the auto-generated 'BuildProperties' 
// bean class. 
// As a workaround, we provide spring with a custom class named '${className}'.

package ${packageName};

import java.util.Properties;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ${className} extends org.springframework.boot.info.BuildProperties {

    public ${className}(Properties entries) {
        super(entries);
    }

    public String getVersion() {
        return \"${versionName}\";
    }
}
`;

    if (saveToFileSync(javaCode, dir, className + '.java', options)) {
        return path.join(dir, className + '.java');
    }

    return null;
}

/**
 * @param {!string} dir 
 * @param {!pkgTypes.Setup} setup
 * @param {types.Strict=} options
 * @returns {types.PromiseOkOrCodeError}
 */
export async function patchRepo(dir, setup, options = { strict: false }) {
    const gitHubRepo = setup.directories[dir].pkgArg.gitHubRepoName;
    const jsFile = `./${gitHubRepo}/patch.js`;
    let dynPatcherModule = null;
    try { dynPatcherModule = await import(jsFile); } catch { }
    // no dynamic patcher ? => good ! there is nothing to patch
    if (dynPatcherModule) {
        return dynPatcherModule.patch(dir, setup, options);
    }
    return { ok: true };
}
